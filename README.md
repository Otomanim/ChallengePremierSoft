# Challenge 

## Project Overview

The challenge involved creating elements using ViewCode, implementing the MVVM architecture, applying clean code principles, utilizing Protocol-Oriented Programming (POP), and managing screens using the Factory pattern. Additionally, dependency injection was employed for better decoupling and testability.

## Tools and Technologies Used

- **ViewCode**: Elements were created programmatically to achieve better control and flexibility over the UI.
- **MVVM Architecture**: The project structure followed the Model-View-ViewModel architecture pattern, enhancing separation of concerns and maintainability.
- **Clean Code Principles**: Methods were implemented adhering to clean code practices to improve readability and maintainability of the codebase.
- **Protocol-Oriented Programming (POP)**: Protocols were used to define interfaces and achieve polymorphism, enhancing flexibility and testability of the code.
- **Factory Pattern**: The Factory pattern was employed to manage the creation of screens, providing a centralized and flexible approach to screen instantiation.
- **Dependency Injection**: Dependency injection was utilized for better decoupling and testability of components within the application.

## Implementation Details

- **ViewCode**: Instead of using Interface Builder, all UI elements were instantiated and configured programmatically within the view controllers.
- **MVVM Architecture**: The project was structured into separate layers for Model, View, and ViewModel, facilitating easier maintenance and testing.
- **Clean Code**: Methods were named descriptively, kept short and focused on a single responsibility, and adhered to naming conventions to enhance code clarity.
- **POP**: Protocols were utilized to define interfaces for various components, allowing for easier composition and reusability of code.
- **Factory Pattern**: A factory class was implemented to centralize the creation of view controllers and manage their instantiation based on specific criteria.
- **Dependency Injection**: Dependencies were injected into components rather than being hardcoded, promoting flexibility, and facilitating unit testing.

## Future Improvements

- Further modularization of components to enhance reusability.
- Implementation of unit tests to ensure code reliability and facilitate refactoring.
- Exploration of other design patterns and architectural approaches for potential optimization and scalability.

## Conclusion

The challenge provided an opportunity to apply various software design principles and patterns, resulting in a well-structured and maintainable codebase. By leveraging ViewCode, MVVM architecture, clean code practices, POP, the Factory pattern, and dependency injection, the project demonstrates a robust foundation for future development and expansion.

---

# Challenge Requirements

## Task Description

1. Show the percentage of candidates for .NET API, iOS, and QA positions.
2. Display the average age of QA candidates.
3. Show the oldest candidate among iOS candidates.
4. Show the youngest candidate among all .NET API candidates.
5. Display the sum of the ages of all .NET API candidates.
6. Show the number of distinct states present in the list.
7. Sort the list of candidates alphabetically and save it as Sorted_AppAcademy_Candidates.csv.

## Bonus Task

- Include the name of the instructor for the position you applied for.
- Given facts about instructors:
  - The iOS instructor is over 20 years old.
  - The .NET API instructor is younger than the iOS instructor.
  - The age of the iOS instructor is a prime number.
  - The first name of the .NET API instructor has 3 vowels.
  - The last letter of the last name of the .NET API instructor is "k".
  - The first letter of the last name of the iOS instructor is "V".
  - The age of the instructors is an odd number.
  - The instructors were born in the same decade.
  - The instructors are less than 31 years old.
  - The assigned position for the instructors (in the spreadsheet) is not the position they will instruct.
  - The instructors are from SC.

## Installation

1. Clone the repository:
git clone https://github.com/Otomanim/Projeto-Marvel.git

2. Run the application on the simulator or device.

---

## License

This project is licensed under the [MIT License](https://opensource.org/licenses/MIT).

---

## Contribution

Contributions are welcome! Please follow the [contribution guidelines](CONTRIBUTING.md).

---

## Authors

- [Evandro Rodrigo Minamoto](https://github.com/Otomanim)

---

## Support

For questions or issues, please create an [issue](https://github.com/Otomanim/DesafioPremierSoft/issues).

---

**Â© 2024 Otomanim**
